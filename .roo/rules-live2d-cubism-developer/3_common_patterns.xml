<?xml version="1.0" encoding="UTF-8"?>
<common_patterns>
  <overview>
    This file provides common code patterns and reusable templates for Live2D Cubism 5 development with the Web SDK and TypeScript. These patterns are based on the best practice of encapsulating logic within a dedicated manager class.
  </overview>

  <pattern name="Live2DApplication_Class_Structure">
    <description>A robust, self-contained class structure for managing the entire Live2D rendering pipeline.</description>
    <context>Use this as the foundation for any Live2D integration. It encapsulates state and provides a clean API, avoiding the global state issues of the official samples.</context>
    <code language="typescript"><![CDATA[
import { CubismFramework, LogLevel } from '@framework/live2dcubismframework';
import { CubismUserModel } from '@framework/model/cubismusermodel';
// Note: Additional utility classes like LAppPal might be needed from the samples.

export class Live2DApplication {
  private _canvas: HTMLCanvasElement;
  private _gl: WebGLRenderingContext;
  private _model: CubismUserModel | null = null;

  constructor(canvas: HTMLCanvasElement) {
    this._canvas = canvas;
    const context = this._canvas.getContext('webgl', { premultipliedAlpha: true });
    if (!context) {
      throw new Error('Failed to get WebGL context.');
    }
    this._gl = context;

    this.initializeCubism();
    this.tick = this.tick.bind(this);
    requestAnimationFrame(this.tick);
  }

  private initializeCubism(): void {
    CubismFramework.startUp({
      logFunction: (message: string) => console.log(message),
      loggingLevel: LogLevel.LogLevel_Verbose
    });
    CubismFramework.initialize();
  }

  public async loadModel(dir: string, fileName: string): Promise<void> {
    // Model loading logic will be implemented here
  }

  private tick(time: number): void {
    // LAppPal.updateTime(); // Utility for time delta calculation

    this._gl.clearColor(0.0, 0.0, 0.0, 0.0); // Transparent background
    this._gl.clear(this._gl.COLOR_BUFFER_BIT);

    if (this._model) {
      this._model.update();
      this._model.draw(this._gl); // Simplified draw call
    }

    requestAnimationFrame(this.tick);
  }

  public dispose(): void {
    // Cleanup logic here
  }
}
]]></code>
    <explanation>
      This class structure initializes the Cubism Framework and sets up a `requestAnimationFrame` loop. It holds references to the canvas, WebGL context, and the loaded model. The `loadModel` method will handle the asynchronous loading, and the `tick` method performs the per-frame update and draw calls.
    </explanation>
  </pattern>

  <pattern name="Asynchronous_Model_Loading">
    <description>The complete, multi-step asynchronous process for loading a Live2D model.</description>
    <context>This logic should be implemented inside the `loadModel` method of the main application class. It shows the correct sequence of fetching the model definition, the `.moc3` file, textures, and initializing the renderer.</context>
    <code language="typescript"><![CDATA[
// Inside the Live2DApplication class...

public async loadModel(modelDir: string): Promise<void> {
  const modelJsonUrl = `${modelDir}/model.model3.json`; // Assuming a standard name
  const response = await fetch(modelJsonUrl);
  const modelJson = await response.json();

  // 1. Load Moc file
  const mocUrl = `${modelDir}/${modelJson.FileReferences.Moc}`;
  const mocResponse = await fetch(mocUrl);
  const mocBuffer = await mocResponse.arrayBuffer();

  // 2. Load Textures
  const textures: WebGLTexture[] = [];
  for (const textureFile of modelJson.FileReferences.Textures) {
    const textureUrl = `${modelDir}/${textureFile}`;
    const texture = await this.createTexture(textureUrl);
    textures.push(texture);
  }

  // 3. Create Model
  const model = new CubismUserModel();
  model.loadModel(mocBuffer);
  
  // 4. Set up Renderer
  const renderer = model.getRenderer();
  renderer.initialize(model);
  renderer.setIsPremultipliedAlpha(true); // Critical for correct blending
  
  // Bind textures
  textures.forEach((texture, i) => {
    renderer.bindTexture(i, texture);
  });
  
  this._model = model;
}

private async createTexture(url: string): Promise<WebGLTexture> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const texture = this._gl.createTexture();
      if (!texture) return reject(new Error("Failed to create texture."));
      
      this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, img);
      
      resolve(texture);
    };
    img.onerror = reject;
    img.src = url;
  });
}
]]></code>
    <explanation>
      This pattern demonstrates the full asynchronous loading chain. It fetches the manifest (`.model3.json`), then uses the paths within it to fetch the core model data (`.moc3`) and textures. It correctly handles creating and binding WebGL textures and sets the crucial `premultipliedAlpha` property to prevent rendering artifacts.
    </explanation>
  </pattern>

  <pattern name="Motion_Playback">
    <description>Starting a motion from a specific group with a given priority.</description>
    <context>Use this pattern to trigger animations, such as idle loops or reactions to user input. The priority system is key to managing which animations can interrupt others.</context>
    <code language="typescript"><![CDATA[
// Assuming 'model' is an initialized CubismUserModel instance

// Standard priorities
const PriorityIdle = 1;
const PriorityNormal = 2;
const PriorityForce = 3;

// Start a motion from the "Idle" group, at index 0, with idle priority.
model.motionManager.startMotion("Idle", 0, PriorityIdle);

// Example of an interactive motion that should interrupt idle.
function onTap() {
  model.motionManager.startMotion("TapBody", 0, PriorityForce);
}
]]></code>
    <explanation>
      This pattern shows how to use the `startMotion` method on the model's `motionManager`. It requires the motion group name (defined in the `.model3.json`), the index within that group, and a priority level. Higher priority motions will correctly interrupt and play over lower priority ones.
    </explanation>
  </pattern>
</common_patterns>