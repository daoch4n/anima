<tool_usage_guide>
  <tool_priorities>
    <priority level="1">
      <tool>codebase_search</tool>
      <when>Always use this first to locate existing Live2D implementations, such as a central manager class or the main rendering loop.</when>
      <why>Semantic search is more effective than file-based searching for finding functional components when you don't know the exact file names.</why>
    </priority>
    <priority level="2">
      <tool>read_file</tool>
      <when>After identifying key files (`index.html`, `vite.config.mts`, `tsconfig.json`, the main application class) with `codebase_search` or `list_files`.</when>
      <why>To get the full and exact content of files before attempting to modify them, ensuring diffs are accurate and preventing errors.</why>
    </priority>
    <priority level="3">
      <tool>apply_diff</tool>
      <when>For making targeted changes to existing files, such as adding a path alias to `tsconfig.json` or inserting the Core script tag into `index.html`.</when>
      <why>It's the most efficient and reliable tool for surgical modifications of existing code and configuration.</why>
    </priority>
    <priority level="4">
      <tool>write_to_file</tool>
      <when>For creating new files, such as a new `Live2DApplication.ts` class, based on the established common patterns.</when>
      <why>This is the primary tool for scaffolding new components in the project.</why>
    </priority>
  </tool_priorities>

  <tool_specific_guidance>
    <tool name="apply_diff">
      <best_practices>
        <practice>Always use `read_file` first to get the exact content, including whitespace, to ensure the `SEARCH` block matches perfectly.</practice>
        <practice>Combine multiple related changes in a single `apply_diff` operation for efficiency.</practice>
      </best_practices>
      <example scenario="Adding the @framework path alias to tsconfig.json"><![CDATA[
<!-- First, read the file to get the exact content of compilerOptions -->
<read_file>
  <path>tsconfig.json</path>
</read_file>

<!-- Then, apply the change -->
<apply_diff>
  <path>tsconfig.json</path>
  <diff>
<<<<<< SEARCH
    "compilerOptions": {
      "target": "ES2020",
      "useDefineForClassFields": true,
      "module": "ESNext",
      // ... other options
    }
=======
    "compilerOptions": {
      "target": "ES2020",
      "useDefineForClassFields": true,
      "module": "ESNext",
      // ... other options
      "baseUrl": ".",
      "paths": {
        "@framework/*": ["src/lib/live2d/framework/*"]
      }
    }
>>>>>>> REPLACE
  </diff>
</apply_diff>
      ]]></example>
    </tool>

    <tool name="write_to_file">
      <best_practices>
        <practice>Use this for creating new TypeScript or configuration files.</practice>
        <practice>When creating a new class, use the full structure from `3_common_patterns.xml` to ensure it's complete and follows best practices.</practice>
      </best_practices>
      <example scenario="Scaffolding a new Live2D application class"><![CDATA[
<write_to_file>
  <path>src/Live2DApplication.ts</path>
  <content>
import { CubismFramework, LogLevel } from '@framework/live2dcubismframework';
import { CubismUserModel } from '@framework/model/cubismusermodel';

export class Live2DApplication {
  private _canvas: HTMLCanvasElement;
  private _gl: WebGLRenderingContext;
  private _model: CubismUserModel | null = null;

  constructor(canvas: HTMLCanvasElement) {
    this._canvas = canvas;
    const context = this._canvas.getContext('webgl', { premultipliedAlpha: true });
    if (!context) {
      throw new Error('Failed to get WebGL context.');
    }
    this._gl = context;

    this.initializeCubism();
    this.tick = this.tick.bind(this);
    requestAnimationFrame(this.tick);
  }
  
  // ... rest of the class implementation from common_patterns ...
}
  </content>
</write_to_file>
      ]]></example>
    </tool>
  </tool_specific_guidance>
</tool_usage_guide>